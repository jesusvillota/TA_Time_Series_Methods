**IMPORTANT**: This task requires the agent to DIRECTLY PERFORM git commit and push operations using terminal commands. The agent must NOT create scripts, automation tools, or helper programs to perform these operations. The agent should execute git commands directly through the available terminal tools.

The agent MUST directly execute git commands to commit and push changes to GitHub following the mandatory process outlined below.

This is a CRITICAL REQUIREMENT for ALL commits and pushes. Must be used EVERY TIME before creating any git commit or push. No exceptions.

## What This Task Means

**The agent must directly execute git commands** through terminal tools to:
- Stage files using `git add`
- Review changes using `git diff`
- Commit changes using `git commit`
- Push changes using `git push`

**The agent must NOT:**
- Create Python scripts to automate git operations
- Build automation tools or helper programs
- Create shell scripts or bash files for git operations
- Delegate git operations to external scripts or tools

All git operations must be performed directly by the agent executing terminal commands.

## Process Overview

The agent MUST directly execute the following workflow when committing and pushing changes:

1. **Identify Change Groups** - Review all modified files using `git status` and `git diff` to identify logical groupings by similarity and relevance
2. **Stage Changes** - Execute `git add` commands directly via terminal to stage only related changes for each commit
3. **Review Changes** - Execute `git diff --staged` command directly via terminal to review all staged modifications
4. **Generate Commit Message** - Create a descriptive commit message following the format below
5. **Commit Changes** - Execute `git commit` command directly via terminal with the generated message
6. **Verify Commit** - Confirm the commit was successful by checking command output
7. **Push to Remote** - Execute `git push origin [branch-name]` command directly via terminal to push changes to GitHub
8. **Confirm Push** - Verify that the push to GitHub was successful by checking command output
9. **Repeat for Remaining Groups** - If there are additional groups of unrelated changes, repeat steps 2-8 for each group

## Mandatory Commit Process

BEFORE ANY "git commit" COMMAND:

1. ALWAYS run `git diff --staged` first to see changes
2. ALWAYS analyze the staged changes thoroughly
3. ALWAYS generate a commit message following the format below
4. NEVER commit without following this process

## Commit Organization by Similarity and Relevance

**CRITICAL**: Commits MUST be organized by similarity and relevance. Similar and relevant changes should be committed together, but do NOT commit all existing changes systematically under the same commit.

### Organization Principles

1. **Group Related Changes**: Similar and relevant changes should be committed together in a single commit
   - Changes to the same file or component
   - Changes that implement a single feature or fix
   - Changes that address the same issue or task
   - Changes that are logically related and form a cohesive unit

2. **Separate Unrelated Changes**: Different, unrelated changes should be committed separately
   - Changes to different files serving different purposes
   - Changes implementing different features
   - Changes addressing different issues or tasks
   - Changes that are logically independent

3. **Review Before Staging**: Before staging files, analyze all changes to determine logical groupings
   - Use `git status` to see all modified files
   - Use `git diff` to review changes in each file
   - Identify which changes are related and which are independent
   - Stage related changes together for each commit

### Examples of Good Commit Organization

**Good - Related changes grouped together:**
```bash
# Commit 1: All documentation updates
git add README.md SETUP_GUIDE.md
git commit -m "Update documentation for installation process"

# Commit 2: All code fixes for a specific bug
git add src/utils/logger.py src/scripts/process_data.py
git commit -m "Fix data processing error in logger module"

# Commit 3: All notebook improvements
git add sessions/session_1/simulations.ipynb sessions/session_2/00_data_cleaning.ipynb
git commit -m "Add inline comments to notebook code cells"
```

**Bad - All changes in one commit:**
```bash
# DON'T DO THIS - mixing unrelated changes
git add README.md src/utils/logger.py sessions/session_1/simulations.ipynb
git commit -m "Update various files"
```

### Decision Criteria

When deciding whether to group changes or separate them, consider:

- **Functional Relationship**: Do the changes work together to accomplish a single goal?
- **Logical Coherence**: Do the changes form a coherent, understandable unit?
- **Reviewability**: Would reviewing these changes together make sense?
- **Revertibility**: If you needed to revert these changes, would you want to revert them together?

### Workflow for Multiple Commits

When you have multiple unrelated changes:

1. **Identify Change Groups**: Review all modified files and group them by similarity/relevance
2. **Stage First Group**: Use `git add` to stage only the files in the first group
3. **Review and Commit**: Run `git diff --staged`, then commit with appropriate message
4. **Push First Commit**: Push the first commit to remote
5. **Repeat for Each Group**: Repeat steps 2-4 for each remaining group of related changes
6. **Verify Completion**: Use `git status` to confirm all changes have been committed and pushed

### Forbidden Practices

- NEVER commit all modified files in a single commit if they are unrelated
- NEVER use `git add .` or `git add -A` without first reviewing what will be committed
- NEVER create commits that mix different types of changes (e.g., documentation + code fixes + configuration)
- NEVER commit changes just because they exist - always organize by logical relationship

## Required Commit Message Format

### Summary Line (under 50 characters)

- Use present tense imperative mood
- Be specific and descriptive
- Example: "Add inline comments to Stata code", "Update section titles to remove Exercise X terminology"

### Detailed Description (when applicable)

- Explain WHAT was changed (specific files/sections)
- Explain WHY it was changed (reasoning/purpose)
- List affected components/files (at least 2-3 key files)
- Include any important context or decision rationale

### Format Template

```markdown
[Action Verb] [what] [for/in/of] [component]

- Change 1 with brief explanation
- Change 2 with brief explanation
- Change 3 with brief explanation

[Optional: Explain reasoning or impact of changes]
```

## Best Practices

- Use clear, descriptive commit messages that tell the story of what changed
- Use present tense ("Add feature" not "Added feature")
- Include the "why" not just the "what"
- Start summary with action verb (Add, Update, Fix, Remove, Refactor, etc.)
- Be specific about what components/files are affected
- Include file paths when referencing specific files

## Mandatory Push Process

AFTER EACH "git commit":

1. ALWAYS run `git push origin [current-branch]` to push to GitHub
2. ALWAYS verify the push was successful (check output for confirmation)
3. NEVER leave commits without pushing to the remote repository
4. If push fails, diagnose and resolve the issue before proceeding

### Push Verification

- Look for output confirming successful push to GitHub
- Verify no errors occurred during the push
- If authentication issues arise, troubleshoot and retry

## FORBIDDEN Elements

- NEVER include "Generated with Copilot"
- NEVER include "Co-Authored-By: Copilot"
- NEVER use generic messages like "Update files", "Fix issues", or "Minor changes"
- NEVER commit without pushing (unless explicitly instructed otherwise)
- NEVER leave work uncommitted and unpushed at the end of a task

## Example Workflow

### Single Related Change Group

```bash
# 1. Review all changes to identify groups
git status
git diff

# 2. Stage related changes (e.g., all documentation updates)
git add README.md SETUP_GUIDE.md

# 3. Review staged changes
git diff --staged

# 4. Create and execute commit with proper message
git commit -m "Update documentation for installation process

- Add new installation steps to README.md
- Update SETUP_GUIDE.md with dependency requirements
- Clarify Python version compatibility"

# 5. Push to GitHub
git push origin main

# 6. Verify successful push
# Output should show: "... main -> main"
```

### Multiple Unrelated Change Groups

```bash
# 1. Review all changes to identify groups
git status
git diff

# 2. First group: Stage related changes (e.g., documentation)
git add README.md SETUP_GUIDE.md
git diff --staged
git commit -m "Update documentation for installation process

- Add new installation steps to README.md
- Update SETUP_GUIDE.md with dependency requirements"
git push origin main

# 3. Second group: Stage different related changes (e.g., code fixes)
git add src/utils/logger.py src/scripts/process_data.py
git diff --staged
git commit -m "Fix data processing error in logger module

- Correct timestamp formatting in logger.py
- Fix data type conversion in process_data.py
- Resolves issue with monthly data aggregation"
git push origin main

# 4. Third group: Stage another set of related changes (e.g., notebook updates)
git add sessions/session_1/simulations.ipynb sessions/session_2/00_data_cleaning.ipynb
git diff --staged
git commit -m "Add inline comments to notebook code cells

- Document each code cell with explanation of functionality
- Applied to simulations.ipynb and data_cleaning.ipynb
- Improves student understanding of statistical methods"
git push origin main

# 5. Verify all changes are committed
git status
# Should show: "nothing to commit, working tree clean"
```

## Reminder

- If you complete any task that involves modifying files, STOP before finishing and follow this complete commit and push workflow
- NEVER mark a task as complete without committing and pushing changes
- ALWAYS verify both commit and push succeeded before considering work done